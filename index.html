<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Clash-ish Royale</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Poppins:wght@400;600;700;900&display=swap');
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }
        
        html, body {
            width: 100%;
            height: 100%;
            overflow: hidden;
            font-family: 'Poppins', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            display: flex;
            justify-content: center;
            align-items: center;
        }
        
        #app-wrapper {
            width: 100%;
            height: 100%;
            max-width: 450px;
            max-height: 100vh;
            position: relative;
            background: linear-gradient(to bottom, #0a0a0a, #1a1a1a);
            box-shadow: 0 0 50px rgba(0,0,0,0.8);
        }
        
        #game-container {
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            position: relative;
        }
        
        #game-canvas {
            width: 100%;
            flex-grow: 1;
            background: linear-gradient(to bottom, #2e7d32, #1b5e20);
            touch-action: none;
        }
        
        #ui-bar {
            background: linear-gradient(to bottom, #37474f, #263238);
            padding: 0.75rem;
            border-top: 3px solid #455a64;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0.5rem;
            box-shadow: 0 -4px 12px rgba(0,0,0,0.4);
        }
        
        #elixir-container {
            background: radial-gradient(circle, #4a148c, #6a1b9a);
            border-radius: 2rem;
            height: 2.5rem;
            width: 90%;
            max-width: 200px;
            border: 3px solid #ab47bc;
            overflow: hidden;
            position: relative;
            box-shadow: inset 0 0 10px rgba(0,0,0,0.5);
        }
        
        #elixir-bar {
            width: 50%;
            height: 100%;
            background: linear-gradient(90deg, #ba68c8, #f3e5f5);
            transition: width 0.1s linear;
            box-shadow: 0 0 15px #e040fb;
        }
        
        #elixir-count {
            position: absolute;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            font-size: 1.25rem;
            font-weight: 900;
            color: #fff;
            text-shadow: 2px 2px 4px #4a148c;
        }
        
        .card {
            width: 70px;
            height: 98px;
            background: linear-gradient(135deg, #3e2723, #5d4037);
            border: 3px solid #ffd54f;
            border-radius: 8px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-end;
            padding: 0.25rem;
            font-weight: 900;
            color: #fff;
            box-shadow: 0 4px 10px rgba(0,0,0,0.4);
            cursor: pointer;
            transition: all 0.2s ease;
            position: relative;
            flex-shrink: 0;
        }
        
        #card-hand {
            display: flex;
            justify-content: center;
            gap: 0.5rem;
            width: 100%;
            padding: 0 0.5rem;
        }
        
        .card:active:not(.disabled) {
            transform: scale(0.95);
        }
        
        .card.selected {
            border-color: #f48fb1;
            transform: translateY(-8px) scale(1.05);
            box-shadow: 0 0 20px #f06292;
        }
        
        .card .elixir-cost {
            position: absolute;
            top: -10px;
            left: -10px;
            background: radial-gradient(#ce93d8, #ab47bc);
            color: #fff;
            font-size: 0.9rem;
            width: 28px;
            height: 28px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            border: 2px solid #f3e5f5;
            font-weight: 900;
            box-shadow: 0 2px 5px rgba(0,0,0,0.3);
        }
        
        .card .card-name {
            font-size: 0.65rem;
            text-align: center;
            text-shadow: 1px 1px 2px #000;
            background: rgba(0,0,0,0.6);
            width: 100%;
            padding: 2px 0;
            border-radius: 0 0 5px 5px;
        }
        
        .card .card-icon {
            font-size: 2rem;
            margin: auto;
            filter: drop-shadow(2px 2px 4px #000);
        }
        
        .card.disabled {
            filter: grayscale(100%) brightness(0.6);
            cursor: not-allowed;
        }
        
        #game-over-screen {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.9);
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: #fff;
            z-index: 100;
            padding: 1rem;
        }
        
        #game-over-text {
            font-size: 2.5rem;
            font-weight: 900;
            margin-bottom: 2rem;
            text-align: center;
            text-shadow: 2px 2px 4px #000;
        }
        
        .game-button {
            padding: 1rem 2rem;
            font-size: 1.2rem;
            font-weight: 900;
            color: #fff;
            background: linear-gradient(90deg, #f06292, #f48fb1);
            border: 3px solid #f8bbd0;
            border-radius: 1rem;
            cursor: pointer;
            transition: all 0.25s ease;
            box-shadow: 0 6px 20px rgba(0,0,0,0.5);
            margin: 0.5rem;
            border: none;
        }
        
        .game-button:active {
            transform: scale(0.95);
        }
        
        .menu-screen {
            width: 100%;
            height: 100%;
            padding: 2rem 1rem;
            color: #fff;
            display: flex;
            flex-direction: column;
            align-items: center;
            overflow-y: auto;
            background: linear-gradient(to bottom, #1a237e, #0d47a1);
        }
        
        .menu-content {
            width: 100%;
            max-width: 400px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        .card-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(90px, 1fr));
            gap: 1rem;
            width: 100%;
            padding: 1rem;
        }
        
        .shop-card-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            background: rgba(0,0,0,0.4);
            padding: 1rem;
            border-radius: 12px;
        }
        
        .auth-container {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 24px;
            padding: 2rem;
            max-width: 400px;
            width: 90%;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
        }
        
        .auth-input {
            width: 100%;
            padding: 0.875rem 1rem;
            border: 2px solid #e0e0e0;
            border-radius: 12px;
            font-size: 1rem;
            transition: all 0.3s ease;
            margin-bottom: 1rem;
        }
        
        .auth-input:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }
        
        .auth-button {
            width: 100%;
            padding: 1rem;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            border-radius: 12px;
            font-size: 1.1rem;
            font-weight: 700;
            cursor: pointer;
            transition: transform 0.2s ease;
            margin-bottom: 0.75rem;
        }
        
        .auth-button:hover {
            transform: translateY(-2px);
        }
        
        .auth-button:active {
            transform: scale(0.98);
        }
        
        .auth-button.secondary {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
        }
        
        .error-message {
            background: #fee;
            color: #c33;
            padding: 0.75rem;
            border-radius: 8px;
            margin-bottom: 1rem;
            font-size: 0.9rem;
            text-align: center;
        }
        
        .success-message {
            background: #efe;
            color: #3c3;
            padding: 0.75rem;
            border-radius: 8px;
            margin-bottom: 1rem;
            font-size: 0.9rem;
            text-align: center;
        }
        
        @media (max-width: 380px) {
            #game-over-text {
                font-size: 2rem;
            }
            .game-button {
                padding: 0.75rem 1.5rem;
                font-size: 1rem;
            }
            .card .card-icon {
                font-size: 1.5rem;
            }
        }
    </style>
</head>
<body>
    <div id="app-wrapper">
        <div id="game-container"></div>
    </div>
    <script type="module">
        // --- AUTHENTICATION & USER MANAGEMENT ---
        let currentUser = null;
        const USERS_KEY = 'clash_royale_users';

        function loadUsers() {
            try {
                const data = localStorage.getItem(USERS_KEY);
                if (data) {
                    const parsed = JSON.parse(data);
                    console.log('Loaded users from localStorage:', Object.keys(parsed));
                    return parsed;
                }
                console.log('No users found in localStorage');
                return {};
            } catch (error) {
                console.error('Error loading users from localStorage:', error);
                return {};
            }
        }

        function saveUsers(users) {
            try {
                const dataString = JSON.stringify(users);
                localStorage.setItem(USERS_KEY, dataString);
                console.log('Saved users to localStorage:', Object.keys(users));
                return true;
            } catch (error) {
                console.error('Error saving to localStorage:', error);
                alert('Failed to save data. Your browser storage might be full.');
                return false;
            }
        }

        function registerUser(username, password) {
            if (!username || !password) {
                return { success: false, message: 'Username and password required' };
            }
            
            if (username.length < 3) {
                return { success: false, message: 'Username must be at least 3 characters' };
            }
            
            if (password.length < 4) {
                return { success: false, message: 'Password must be at least 4 characters' };
            }

            try {
                const users = loadUsers();
                console.log('Current users before registration:', Object.keys(users));
                
                if (users[username]) {
                    return { success: false, message: 'Username already exists' };
                }

                users[username] = {
                    password: btoa(password),
                    trophies: 0,
                    ownedCards: [...INITIAL_DECK],
                    currentDeck: [...INITIAL_DECK],
                    createdAt: Date.now()
                };

                console.log('Users after adding new user:', Object.keys(users));
                const saveResult = saveUsers(users);
                console.log('Save result:', saveResult);
                
                // Verify the save worked
                const verifyUsers = loadUsers();
                console.log('Verification - users after save:', Object.keys(verifyUsers));
                
                if (verifyUsers[username]) {
                    return { success: true, message: 'Account created successfully!' };
                } else {
                    return { success: false, message: 'Account created but verification failed. Try logging in anyway.' };
                }
            } catch (error) {
                console.error('Registration error:', error);
                return { success: false, message: 'Failed to create account: ' + error.message };
            }
        }

        function loginUser(username, password) {
            if (!username || !password) {
                return { success: false, message: 'Username and password required' };
            }

            try {
                const users = loadUsers();
                console.log('All users during login:', Object.keys(users));
                console.log('Looking for username:', username);
                console.log('User exists?', users[username] ? 'Yes' : 'No');
                
                const user = users[username];

                if (!user) {
                    return { success: false, message: `User '${username}' not found. Registered users: ${Object.keys(users).join(', ') || 'none'}` };
                }

                console.log('User found, checking password...');
                const storedPassword = atob(user.password);
                console.log('Password match?', storedPassword === password);

                if (storedPassword !== password) {
                    return { success: false, message: 'Incorrect password' };
                }

                currentUser = username;
                trophies = user.trophies || 0;
                ownedCards = user.ownedCards || [...INITIAL_DECK];
                currentDeck = user.currentDeck || [...INITIAL_DECK];

                console.log('Login successful for user:', currentUser);
                return { success: true, message: 'Login successful!' };
            } catch (error) {
                console.error('Login error:', error);
                return { success: false, message: 'Login failed: ' + error.message };
            }
        }

        function logoutUser() {
            saveCurrentUserData();
            currentUser = null;
            trophies = 0;
            ownedCards = [...INITIAL_DECK];
            currentDeck = [...INITIAL_DECK];
            changeScreen('auth');
        }

        function saveCurrentUserData() {
            if (!currentUser) return;

            const users = loadUsers();
            if (users[currentUser]) {
                users[currentUser].trophies = trophies;
                users[currentUser].ownedCards = ownedCards;
                users[currentUser].currentDeck = currentDeck;
                users[currentUser].lastUpdated = Date.now();
                saveUsers(users);
                console.log('Saved data for user:', currentUser);
            }
        }

        // --- GAME STATE & PERSISTENCE ---
        let trophies = 0;
        let ownedCards = [];
        let currentDeck = [];
        const SHOP_CARDS = ['knight', 'archer', 'giant', 'prince', 'cannon', 'minions', 'balloon'];
        const INITIAL_DECK = ['knight', 'archer', 'giant', 'cannon'];

        function saveUserData() {
            saveCurrentUserData();
        }

        // --- GAME SETUP & CONSTANTS ---
        const gameContainer = document.getElementById('game-container');
        let currentScreen = 'auth';
        let ARENA_WIDTH = 450;
        let ARENA_HEIGHT = 700;
        const MAX_ELIXIR = 10;
        const ELIXIR_REGEN_RATE = 1.0 / 1.4;
        const AI_SPAWN_COOLDOWN = 4000;
        const MATCH_DURATION = 120;
        const DOUBLE_ELIXIR_TIME = 60;

        function updateDimensions() {
            const wrapper = document.getElementById('app-wrapper');
            ARENA_WIDTH = wrapper.clientWidth;
            ARENA_HEIGHT = wrapper.clientHeight - 180;
        }

        // --- CARD DEFINITIONS ---
        const CARD_DEFS = {
            knight: { 
                elixir: 3, type: 'KNIGHT', hp: 1400, damage: 150, attackSpeed: 1.1, 
                attackRange: 15, speed: 0.8, size: 20, targetType: 'GROUND', 
                icon: 'üõ°Ô∏è', visionRange: 500 
            },
            archer: { 
                elixir: 3, type: 'ARCHER', hp: 280, damage: 85, attackSpeed: 1.0, 
                attackRange: 100, speed: 0.7, size: 15, targetType: 'ANY', 
                icon: 'üèπ', visionRange: 500 
            },
            giant: { 
                elixir: 5, type: 'GIANT', hp: 3400, damage: 200, attackSpeed: 1.5, 
                attackRange: 15, speed: 0.5, size: 30, targetType: 'BUILDING', 
                icon: 'üí™', visionRange: 500 
            },
            prince: { 
                elixir: 5, type: 'PRINCE', hp: 1600, damage: 325, attackSpeed: 1.4, 
                attackRange: 15, speed: 1.0, size: 22, targetType: 'GROUND', 
                icon: 'üèá', visionRange: 500 
            },
            cannon: { 
                elixir: 3, type: 'CANNON', hp: 700, damage: 90, attackSpeed: 0.8, 
                attackRange: 120, speed: 0, size: 35, targetType: 'GROUND', 
                icon: 'üéØ', visionRange: 0, lifetime: 30, isBuilding: true 
            },
            minions: {
                elixir: 3, type: 'MINIONS', hp: 200, damage: 80, attackSpeed: 1.0,
                attackRange: 50, speed: 1.2, size: 12, targetType: 'ANY',
                icon: 'ü¶á', visionRange: 500
            },
            balloon: {
                elixir: 5, type: 'BALLOON', hp: 1200, damage: 600, attackSpeed: 3.0,
                attackRange: 15, speed: 0.6, size: 26, targetType: 'BUILDING',
                icon: 'üéà', visionRange: 500
            },
        };

        const TOWER_DEFS = {
            PRINCESS: { hp: 2400, damage: 90, attackSpeed: 0.8, attackRange: 150, size: 40 },
            KING: { hp: 4200, damage: 100, attackSpeed: 1.0, attackRange: 140, size: 50 }
        };

        // --- GAME STATE ---
        let playerElixir, aiElixir, units, projectiles, towers, buildings, selectedCard, lastTime, gameTime, aiSpawnTimer, gameState, matchTimeLeft;
        let canvas, ctx, elixirBar, elixirCount, gameOverScreen, gameOverText;
        let PLACEMENT_Y_LIMIT, AI_PLACEMENT_Y_LIMIT, RIVER_Y, LEFT_LANE_X, RIGHT_LANE_X, BRIDGE_Y_TOP, BRIDGE_Y_BOTTOM;

        function getDistance(obj1, obj2) {
            const dx = obj1.x - obj2.x;
            const dy = obj1.y - obj2.y;
            return Math.sqrt(dx * dx + dy * dy);
        }

        // --- ARENA INITIALIZATION ---
        function initArena() {
            updateDimensions();
            
            RIVER_Y = ARENA_HEIGHT / 2;
            PLACEMENT_Y_LIMIT = ARENA_HEIGHT / 2 + Math.min(100, ARENA_HEIGHT * 0.15);
            AI_PLACEMENT_Y_LIMIT = ARENA_HEIGHT / 2 - Math.min(100, ARENA_HEIGHT * 0.15);
            LEFT_LANE_X = ARENA_WIDTH * 0.3;
            RIGHT_LANE_X = ARENA_WIDTH * 0.7;
            BRIDGE_Y_TOP = RIVER_Y - 30;
            BRIDGE_Y_BOTTOM = RIVER_Y + 30;
            
            playerElixir = 5.0;
            aiElixir = 5.0;
            matchTimeLeft = MATCH_DURATION;
            units = [];
            projectiles = [];
            buildings = [];
            selectedCard = null;
            lastTime = 0;
            gameTime = 0;
            aiSpawnTimer = AI_SPAWN_COOLDOWN;
            gameState = 'playing';
            
            towers = [
                { id: 1, owner: 'player', type: 'PRINCESS', ...TOWER_DEFS.PRINCESS, maxHp: TOWER_DEFS.PRINCESS.hp, x: ARENA_WIDTH * 0.25, y: ARENA_HEIGHT - ARENA_HEIGHT * 0.25, lastAttackTime: 0 },
                { id: 2, owner: 'player', type: 'PRINCESS', ...TOWER_DEFS.PRINCESS, maxHp: TOWER_DEFS.PRINCESS.hp, x: ARENA_WIDTH * 0.75, y: ARENA_HEIGHT - ARENA_HEIGHT * 0.25, lastAttackTime: 0 },
                { id: 3, owner: 'player', type: 'KING', ...TOWER_DEFS.KING, maxHp: TOWER_DEFS.KING.hp, x: ARENA_WIDTH / 2, y: ARENA_HEIGHT - ARENA_HEIGHT * 0.15, lastAttackTime: 0 },
                { id: 4, owner: 'ai', type: 'PRINCESS', ...TOWER_DEFS.PRINCESS, maxHp: TOWER_DEFS.PRINCESS.hp, x: ARENA_WIDTH * 0.25, y: ARENA_HEIGHT * 0.25, lastAttackTime: 0 },
                { id: 5, owner: 'ai', type: 'PRINCESS', ...TOWER_DEFS.PRINCESS, maxHp: TOWER_DEFS.PRINCESS.hp, x: ARENA_WIDTH * 0.75, y: ARENA_HEIGHT * 0.25, lastAttackTime: 0 },
                { id: 6, owner: 'ai', type: 'KING', ...TOWER_DEFS.KING, maxHp: TOWER_DEFS.KING.hp, x: ARENA_WIDTH / 2, y: ARENA_HEIGHT * 0.15, lastAttackTime: 0 }
            ];
            
            canvas = document.getElementById('game-canvas');
            ctx = canvas.getContext('2d');
            elixirBar = document.getElementById('elixir-bar');
            elixirCount = document.getElementById('elixir-count');
            gameOverScreen = document.getElementById('game-over-screen');
            gameOverText = document.getElementById('game-over-text');
            
            canvas.width = ARENA_WIDTH;
            canvas.height = ARENA_HEIGHT;
            
            updateElixirUI();
            updateCardUI();
            gameOverScreen.style.display = 'none';
            
            document.querySelectorAll('.card').forEach(button => {
                button.addEventListener('click', handleCardClick);
            });
            
            canvas.addEventListener('click', handleCanvasClick);
            canvas.addEventListener('touchstart', handleTouchStart, { passive: false });
            
            requestAnimationFrame(gameLoop);
        }

        // --- GAME LOOP ---
        function gameLoop(timestamp) {
            if (gameState !== 'playing' || currentScreen !== 'arena') return;
            const deltaTime = (timestamp - (lastTime || timestamp)) / 1000.0;
            lastTime = timestamp;
            gameTime += deltaTime;
            matchTimeLeft -= deltaTime;
            
            if (matchTimeLeft <= 0) {
                endGameByTime();
                return;
            }
            
            updateElixir(deltaTime);
            updateAI(deltaTime);
            updateUnits(deltaTime);
            updateBuildings(deltaTime);
            updateTowers(deltaTime);
            updateProjectiles(deltaTime);
            draw();
            checkGameOver();
            requestAnimationFrame(gameLoop);
        }

        function updateElixir(deltaTime) {
            const elixirMultiplier = matchTimeLeft <= DOUBLE_ELIXIR_TIME ? 2 : 1;
            
            if (playerElixir < MAX_ELIXIR) {
                playerElixir = Math.min(MAX_ELIXIR, playerElixir + ELIXIR_REGEN_RATE * deltaTime * elixirMultiplier);
            }
            
            if (aiElixir < MAX_ELIXIR) {
                aiElixir = Math.min(MAX_ELIXIR, aiElixir + ELIXIR_REGEN_RATE * deltaTime * elixirMultiplier);
            }
            
            updateElixirUI();
        }

        function updateElixirUI() {
            const elixirInt = Math.floor(playerElixir);
            elixirCount.textContent = elixirInt;
            elixirBar.style.width = `${(playerElixir / MAX_ELIXIR) * 100}%`;
        }

        function updateCardUI() {
            document.querySelectorAll('.card').forEach(button => {
                const cardName = button.dataset.card;
                if (!cardName) return;
                const card = CARD_DEFS[cardName];
                if (playerElixir < card.elixir) {
                    button.classList.add('disabled');
                } else {
                    button.classList.remove('disabled');
                }
                if (cardName === selectedCard) {
                    button.classList.add('selected');
                } else {
                    button.classList.remove('selected');
                }
            });
        }

        function updateAI(deltaTime) {
            aiSpawnTimer -= deltaTime * 1000;
            if (aiSpawnTimer <= 0) {
                aiSpawnTimer = AI_SPAWN_COOLDOWN + Math.random() * 2000;
                const availableCards = ['knight', 'archer', 'giant', 'prince', 'cannon', 'minions', 'balloon'].filter(name => {
                    const card = CARD_DEFS[name];
                    return card && aiElixir >= card.elixir;
                });
                
                if (availableCards.length > 0) {
                    const cardName = availableCards[Math.floor(Math.random() * availableCards.length)];
                    const card = CARD_DEFS[cardName];
                    
                    if (aiElixir >= card.elixir) {
                        const spawnX = Math.random() < 0.5 ? LEFT_LANE_X : RIGHT_LANE_X;
                        const spawnY = Math.random() * (AI_PLACEMENT_Y_LIMIT - 50) + 50;
                        spawnUnit(cardName, 'ai', spawnX, spawnY);
                        aiElixir -= card.elixir;
                    }
                }
            }
        }

        function updateBuildings(deltaTime) {
            for (let i = buildings.length - 1; i >= 0; i--) {
                const building = buildings[i];
                
                building.lifetime -= deltaTime;
                const hpLossPerSecond = building.maxHp / 30;
                building.hp -= hpLossPerSecond * deltaTime;
                
                if (building.hp <= 0 || building.lifetime <= 0) {
                    buildings.splice(i, 1);
                    continue;
                }
                
                if (!building.target || building.target.hp <= 0 || getDistance(building, building.target) > building.attackRange) {
                    const enemyOwner = building.owner === 'player' ? 'ai' : 'player';
                    building.target = findClosestTarget(building, units.filter(u => 
                        u.owner === enemyOwner && 
                        u.hp > 0 && 
                        getDistance(building, u) <= building.attackRange
                    ));
                }
                
                if (building.target) {
                    const attackCooldown = 1.0 / building.attackSpeed;
                    if (gameTime - building.lastAttackTime >= attackCooldown) {
                        building.lastAttackTime = gameTime;
                        spawnProjectile(building, building.target);
                    }
                }
            }
        }

        function updateUnits(deltaTime) {
            for (let i = units.length - 1; i >= 0; i--) {
                const unit = units[i];
                if (unit.hp <= 0) {
                    units.splice(i, 1);
                    continue;
                }
                
                const newTarget = findTargetForUnit(unit);
                unit.target = newTarget;
                
                if (!unit.target) {
                    unit.isMoving = true;
                    unit.animationTimer += deltaTime * 10;
                    unit.animationTimer %= (Math.PI * 2);
                    
                    const moveTargetY = unit.owner === 'player' ? 0 : ARENA_HEIGHT;
                    const dy = moveTargetY - unit.y;
                    
                    if (Math.abs(dy) > 5) {
                        const moveSpeed = unit.speed * 60 * deltaTime;
                        unit.y += (dy > 0 ? 1 : -1) * moveSpeed;
                    }
                    continue;
                }
                
                const dist = getDistance(unit, unit.target);
                
                if (dist <= unit.attackRange + unit.size/2) {
                    unit.isMoving = false;
                    const attackCooldown = 1.0 / unit.attackSpeed;
                    if (gameTime - unit.lastAttackTime >= attackCooldown) {
                        unit.lastAttackTime = gameTime;
                        if (unit.attackRange > 20) {
                            spawnProjectile(unit, unit.target);
                        } else {
                            unit.target.hp -= unit.damage;
                        }
                    }
                } else {
                    unit.isMoving = true;
                    unit.animationTimer += deltaTime * 10;
                    unit.animationTimer %= (Math.PI * 2);
                    
                    let moveTargetX = unit.target.x;
                    let moveTargetY = unit.target.y;
                    
                    const onOwnSide = (unit.owner === 'player' && unit.y > BRIDGE_Y_BOTTOM) || 
                                      (unit.owner === 'ai' && unit.y < BRIDGE_Y_TOP);
                    const targetOnOtherSide = (unit.owner === 'player' && unit.target.y < RIVER_Y) || 
                                               (unit.owner === 'ai' && unit.target.y > RIVER_Y);
                    
                    if (onOwnSide && targetOnOtherSide) {
                        moveTargetX = unit.lane === 'left' ? LEFT_LANE_X : RIGHT_LANE_X;
                        moveTargetY = unit.owner === 'player' ? BRIDGE_Y_BOTTOM - 5 : BRIDGE_Y_TOP + 5;
                    }
                    
                    const dx = moveTargetX - unit.x;
                    const dy = moveTargetY - unit.y;
                    const moveDist = Math.sqrt(dx * dx + dy * dy);
                    
                    if (moveDist > 1) {
                        const angle = Math.atan2(dy, dx);
                        const moveSpeed = unit.speed * 60 * deltaTime;
                        unit.x += Math.cos(angle) * moveSpeed;
                        unit.y += Math.sin(angle) * moveSpeed;
                    }
                }
            }
        }

        function findTargetForUnit(unit) {
            const enemyOwner = unit.owner === 'player' ? 'ai' : 'player';
            
            const nearbyBuildings = buildings.filter(b => 
                b.owner === enemyOwner && 
                b.hp > 0 && 
                getDistance(unit, b) <= 200
            );
            
            if (nearbyBuildings.length > 0) {
                return findClosestTarget(unit, nearbyBuildings);
            }
            
            const nearbyUnits = units.filter(u => 
                u.owner === enemyOwner && 
                u.hp > 0 && 
                getDistance(unit, u) <= 150
            );
            
            if (nearbyUnits.length > 0 && unit.targetType !== 'BUILDING') {
                return findClosestTarget(unit, nearbyUnits);
            }
            
            const allTowers = towers.filter(t => 
                t.owner === enemyOwner && 
                t.hp > 0
            );
            
            if (allTowers.length > 0) {
                return findClosestTarget(unit, allTowers);
            }
            
            return null;
        }

        function findClosestTarget(source, targets) {
            let closestTarget = null;
            let minDistance = Infinity;
            for (const target of targets) {
                const dist = getDistance(source, target);
                if (dist < minDistance) {
                    minDistance = dist;
                    closestTarget = target;
                }
            }
            return closestTarget;
        }

        function updateTowers(deltaTime) {
            for (const tower of towers) {
                if (tower.hp <= 0) continue;
                if (!tower.target || tower.target.hp <= 0 || getDistance(tower, tower.target) > tower.attackRange) {
                    const enemyOwner = tower.owner === 'player' ? 'ai' : 'player';
                    tower.target = findClosestTarget(tower, units.filter(u => 
                        u.owner === enemyOwner && 
                        u.hp > 0 && 
                        getDistance(tower, u) <= tower.attackRange
                    ));
                }
                if (tower.target) {
                    const attackCooldown = 1.0 / tower.attackSpeed;
                    if (gameTime - tower.lastAttackTime >= attackCooldown) {
                        tower.lastAttackTime = gameTime;
                        spawnProjectile(tower, tower.target);
                    }
                }
            }
        }

        function updateProjectiles(deltaTime) {
            for (let i = projectiles.length - 1; i >= 0; i--) {
                const proj = projectiles[i];
                const dx = proj.target.x - proj.x;
                const dy = proj.target.y - proj.y;
                const dist = Math.sqrt(dx*dx + dy*dy);
                if (dist < proj.speed * deltaTime * 60) {
                    if(proj.target.hp > 0) {
                        proj.target.hp -= proj.damage;
                    }
                    projectiles.splice(i, 1);
                } else {
                    const angle = Math.atan2(dy, dx);
                    proj.x += Math.cos(angle) * proj.speed * 60 * deltaTime;
                    proj.y += Math.sin(angle) * proj.speed * 60 * deltaTime;
                }
            }
        }

        function checkGameOver() {
            const playerKing = towers.find(t => t.owner === 'player' && t.type === 'KING');
            const aiKing = towers.find(t => t.owner === 'ai' && t.type === 'KING');
            if (aiKing.hp <= 0) {
                endGame(true);
            } else if (playerKing.hp <= 0) {
                endGame(false);
            }
        }

        function endGame(playerWon) {
            gameState = 'over';
            const trophyChange = playerWon ? 30 : -20;
            trophies = Math.max(0, trophies + trophyChange);
            saveUserData();
            gameOverScreen.style.display = 'flex';
            gameOverText.textContent = playerWon ? `YOU WIN! (+${trophyChange} üèÜ)` : `YOU LOSE! (${trophyChange} üèÜ)`;
            gameOverText.style.color = playerWon ? "#4caf50" : "#f44336";
        }

        function endGameByTime() {
            gameState = 'over';
            
            const playerTotalHp = towers.filter(t => t.owner === 'player').reduce((sum, t) => sum + t.hp, 0);
            const aiTotalHp = towers.filter(t => t.owner === 'ai').reduce((sum, t) => sum + t.hp, 0);
            
            const playerWon = playerTotalHp > aiTotalHp;
            const trophyChange = playerWon ? 30 : -20;
            
            trophies = Math.max(0, trophies + trophyChange);
            saveUserData();
            gameOverScreen.style.display = 'flex';
            
            if (playerTotalHp === aiTotalHp) {
                gameOverText.textContent = 'DRAW! (0 üèÜ)';
                gameOverText.style.color = "#ff9800";
            } else {
                gameOverText.textContent = playerWon ? `TIME UP! YOU WIN! (+${trophyChange} üèÜ)` : `TIME UP! YOU LOSE! (${trophyChange} üèÜ)`;
                gameOverText.style.color = playerWon ? "#4caf50" : "#f44336";
            }
        }

        // --- DRAW FUNCTIONS ---
        function draw() {
            ctx.clearRect(0, 0, ARENA_WIDTH, ARENA_HEIGHT);
            drawArena();
            drawTimer();
            towers.forEach(drawTower);
            buildings.forEach(drawBuilding);
            units.forEach(drawUnit);
            projectiles.forEach(drawProjectile);
            if (selectedCard) {
                drawPlacementIndicator();
            }
        }

        function drawTimer() {
            const minutes = Math.floor(matchTimeLeft / 60);
            const seconds = Math.floor(matchTimeLeft % 60);
            const timeString = `${minutes}:${seconds.toString().padStart(2, '0')}`;
            
            ctx.save();
            ctx.font = 'bold 28px Poppins';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'top';
            
            const isDoubleElixir = matchTimeLeft <= DOUBLE_ELIXIR_TIME;
            ctx.fillStyle = isDoubleElixir ? 'rgba(156, 39, 176, 0.8)' : 'rgba(0, 0, 0, 0.6)';
            ctx.fillRect(ARENA_WIDTH/2 - 60, 10, 120, 40);
            
            ctx.fillStyle = isDoubleElixir ? '#e1bee7' : '#ffffff';
            ctx.fillText(timeString, ARENA_WIDTH/2, 20);
            
            if (isDoubleElixir) {
                ctx.font = 'bold 14px Poppins';
                ctx.fillStyle = '#ffeb3b';
                ctx.fillText('2X ELIXIR', ARENA_WIDTH/2, 48);
            }
            
            ctx.restore();
        }

        function drawArena() {
            const grassGradient = ctx.createLinearGradient(0, 0, 0, ARENA_HEIGHT);
            grassGradient.addColorStop(0, '#2e7d32');
            grassGradient.addColorStop(1, '#1b5e20');
            ctx.fillStyle = grassGradient;
            ctx.fillRect(0, 0, ARENA_WIDTH, ARENA_HEIGHT);

            const riverGradient = ctx.createLinearGradient(0, RIVER_Y - 15, 0, RIVER_Y + 15);
            riverGradient.addColorStop(0, '#1976d2');
            riverGradient.addColorStop(1, '#0d47a1');
            ctx.fillStyle = riverGradient;
            ctx.fillRect(0, RIVER_Y - 15, ARENA_WIDTH, 30);

            const bridgeGradient = ctx.createLinearGradient(0, BRIDGE_Y_TOP, 0, BRIDGE_Y_BOTTOM);
            bridgeGradient.addColorStop(0, '#8d6e63');
            bridgeGradient.addColorStop(1, '#6d4c41');
            ctx.fillStyle = bridgeGradient;
            const bridgeWidth = ARENA_WIDTH * 0.15;
            ctx.fillRect(LEFT_LANE_X - bridgeWidth/2, BRIDGE_Y_TOP, bridgeWidth, BRIDGE_Y_BOTTOM - BRIDGE_Y_TOP);
            ctx.fillRect(RIGHT_LANE_X - bridgeWidth/2, BRIDGE_Y_TOP, bridgeWidth, BRIDGE_Y_BOTTOM - BRIDGE_Y_TOP);

            ctx.strokeStyle = 'rgba(255, 255, 255, 0.4)';
            ctx.lineWidth = 3;
            ctx.setLineDash([8, 8]);
            ctx.beginPath();
            ctx.moveTo(0, PLACEMENT_Y_LIMIT);
            ctx.lineTo(ARENA_WIDTH, PLACEMENT_Y_LIMIT);
            ctx.stroke();
            ctx.setLineDash([]);
        }

        function drawTower(tower) {
            const teamColor = tower.owner === 'player' ? '#2196f3' : '#f44336';
            const x = tower.x;
            const y = tower.y;
            const s = tower.size;

            const stoneColor = '#9e9e9e';
            ctx.fillStyle = stoneColor;
            ctx.beginPath();
            ctx.moveTo(x - s/2, y + s/2);
            ctx.lineTo(x - s/1.5, y - s/2);
            ctx.lineTo(x + s/1.5, y - s/2);
            ctx.lineTo(x + s/2, y + s/2);
            ctx.closePath();
            ctx.fill();

            ctx.fillStyle = '#757575';
            ctx.fillRect(x - s/2, y - s/2 - s/3, s, s/3);

            ctx.fillStyle = teamColor;
            ctx.beginPath();
            ctx.moveTo(x - s/4, y - s/2 - s/3 - 15);
            ctx.lineTo(x, y - s/2 - s/3 - 25);
            ctx.lineTo(x + s/4, y - s/2 - s/3 - 15);
            ctx.closePath();
            ctx.fill();

            if (tower.type === 'KING') {
                ctx.fillStyle = stoneColor;
                ctx.fillRect(x - s/1.2, y - s/3, s * 1.4, s/1.5);

                ctx.fillStyle = '#ffeb3b';
                ctx.beginPath();
                ctx.moveTo(x - 12, y - s/2 - s/3 - 5);
                ctx.lineTo(x - 12, y - s/2 - s/3 - 15);
                ctx.lineTo(x - 4, y - s/2 - s/3 - 10);
                ctx.lineTo(x, y - s/2 - s/3 - 20);
                ctx.lineTo(x + 4, y - s/2 - s/3 - 10);
                ctx.lineTo(x + 12, y - s/2 - s/3 - 15);
                ctx.lineTo(x + 12, y - s/2 - s/3 - 5);
                ctx.closePath();
                ctx.fill();
            }

            let yOffset = tower.type === 'KING' ? -s/3 - 20 : -s/2 - 15;
            drawHealthBar(tower, yOffset);
        }

        function drawBuilding(building) {
            const teamColor = building.owner === 'player' ? '#2196f3' : '#f44336';
            const x = building.x;
            const y = building.y;
            const s = building.size;
            
            ctx.fillStyle = '#616161';
            ctx.beginPath();
            ctx.arc(x, y, s/2, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.fillStyle = '#424242';
            ctx.fillRect(x - s/3, y - s/2, s/1.5, s/4);
            
            ctx.strokeStyle = teamColor;
            ctx.lineWidth = 4;
            ctx.beginPath();
            ctx.arc(x, y, s/2 + 2, 0, Math.PI * 2);
            ctx.stroke();
            
            const lifetimePercent = building.lifetime / 30;
            ctx.strokeStyle = lifetimePercent > 0.5 ? '#4caf50' : lifetimePercent > 0.2 ? '#ffeb3b' : '#f44336';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.arc(x, y, s/2 + 6, -Math.PI/2, -Math.PI/2 + (Math.PI * 2 * lifetimePercent));
            ctx.stroke();
            
            drawHealthBar(building, -s/2 - 10);
        }

        function drawUnit(unit) {
            const teamColor = unit.owner === 'player' ? '#2196f3' : '#f44336';
            const x = unit.x;
            const s = unit.size / 2;
            const yOffset = unit.isMoving ? Math.sin(unit.animationTimer) * 3 : 0;
            const finalY = unit.y + yOffset;

            ctx.shadowColor = 'rgba(0,0,0,0.3)';
            ctx.shadowBlur = 5;
            ctx.shadowOffsetY = 3;

            ctx.fillStyle = teamColor;
            ctx.beginPath();
            ctx.ellipse(x, finalY + s/2, s, s/2, 0, 0, Math.PI * 2);
            ctx.fill();

            ctx.shadowColor = 'transparent';

            switch(unit.type) {
                case 'KNIGHT':
                    ctx.fillStyle = '#bdbdbd';
                    ctx.beginPath();
                    ctx.arc(x, finalY - s/2, s * 1.1, 0, Math.PI * 2);
                    ctx.fill();

                    ctx.fillStyle = '#757575';
                    ctx.beginPath();
                    ctx.moveTo(x - s, finalY - s - 5);
                    ctx.lineTo(x, finalY - s - 15);
                    ctx.lineTo(x + s, finalY - s - 5);
                    ctx.closePath();
                    ctx.fill();

                    ctx.strokeStyle = '#e0e0e0';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.moveTo(x + s, finalY);
                    ctx.lineTo(x + s + 10, finalY + 10);
                    ctx.stroke();
                    break;
                case 'ARCHER':
                    ctx.fillStyle = '#ffcc80';
                    ctx.beginPath();
                    ctx.arc(x, finalY - s/4, s * 0.9, 0, Math.PI * 2);
                    ctx.fill();

                    ctx.fillStyle = '#4caf50';
                    ctx.beginPath();
                    ctx.moveTo(x - s, finalY - s);
                    ctx.quadraticCurveTo(x, finalY - s - 10, x + s, finalY - s);
                    ctx.lineTo(x, finalY);
                    ctx.closePath();
                    ctx.fill();

                    ctx.strokeStyle = '#795548';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(x + s/2, finalY - s/2);
                    ctx.quadraticCurveTo(x + s, finalY, x + s/2, finalY + s/2);
                    ctx.stroke();
                    break;
                case 'GIANT':
                    ctx.fillStyle = '#ffcc80';
                    ctx.beginPath();
                    ctx.arc(x, finalY - s/3, s * 1.2, 0, Math.PI * 2);
                    ctx.fill();

                    ctx.fillStyle = '#795548';
                    ctx.beginPath();
                    ctx.arc(x, finalY - s - 5, s * 0.8, 0, Math.PI * 2);
                    ctx.fill();

                    ctx.fillStyle = '#6d4c41';
                    ctx.fillRect(x + s, finalY - s/2, 15, s*1.5);
                    break;
                case 'PRINCE':
                    ctx.fillStyle = '#7e57c2';
                    ctx.beginPath();
                    ctx.ellipse(x, finalY, s * 1.5, s, 0, 0, Math.PI * 2);
                    ctx.fill();

                    ctx.fillStyle = '#ffeb3b';
                    ctx.beginPath();
                    ctx.moveTo(x - 8, finalY - s - 10);
                    ctx.lineTo(x, finalY - s - 20);
                    ctx.lineTo(x + 8, finalY - s - 10);
                    ctx.closePath();
                    ctx.fill();

                    ctx.strokeStyle = '#f57f17';
                    ctx.lineWidth = 4;
                    ctx.beginPath();
                    ctx.moveTo(x + s, finalY);
                    ctx.lineTo(x + s + 20, finalY);
                    ctx.stroke();
                    break;
                case 'BALLOON':
                    ctx.fillStyle = '#ef5350';
                    ctx.beginPath();
                    ctx.arc(x, finalY, s * 1.3, 0, Math.PI * 2);
                    ctx.fill();

                    ctx.strokeStyle = '#c62828';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(x, finalY + s);
                    ctx.lineTo(x, finalY + s * 2);
                    ctx.stroke();

                    ctx.fillStyle = '#8d6e63';
                    ctx.fillRect(x - s/2, finalY + s * 2, s, s * 0.6);
                    break;
                case 'MINIONS':
                    ctx.fillStyle = '#9c27b0';
                    ctx.beginPath();
                    ctx.ellipse(x, finalY, s * 0.8, s * 0.5, 0, 0, Math.PI * 2);
                    ctx.fill();

                    ctx.fillStyle = '#4a148c';
                    ctx.beginPath();
                    ctx.moveTo(x - s, finalY);
                    ctx.quadraticCurveTo(x - s * 1.5, finalY - s, x - s * 0.5, finalY - s/2);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.moveTo(x + s, finalY);
                    ctx.quadraticCurveTo(x + s * 1.5, finalY - s, x + s * 0.5, finalY - s/2);
                    ctx.fill();
                    break;
            }
            drawHealthBar(unit, yOffset - 10);
        }

        function drawHealthBar(entity, yOffset = 0) {
            if (entity.hp <= 0 || entity.hp === entity.maxHp) return;
            const barWidth = entity.size * 1.8;
            const barHeight = 6;
            const barX = entity.x - barWidth / 2;
            const barY = entity.y + yOffset - entity.size / 2 - 15;
            const hpPercent = entity.hp / entity.maxHp;
            ctx.fillStyle = '#424242';
            ctx.fillRect(barX, barY, barWidth, barHeight);
            ctx.fillStyle = hpPercent > 0.5 ? '#66bb6a' : hpPercent > 0.2 ? '#ffeb3b' : '#ef5350';
            ctx.fillRect(barX, barY, barWidth * hpPercent, barHeight);
            ctx.strokeStyle = '#212121';
            ctx.lineWidth = 1.5;
            ctx.strokeRect(barX, barY, barWidth, barHeight);
        }

        function drawProjectile(proj) {
            const teamColor = proj.owner === 'player' ? '#64b5f6' : '#ef5350';
            const glowColor = proj.owner === 'player' ? 'rgba(100, 181, 246, 0.6)' : 'rgba(239, 83, 80, 0.6)';
            ctx.fillStyle = glowColor;
            ctx.beginPath();
            ctx.arc(proj.x, proj.y, proj.size * 2.5, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = teamColor;
            ctx.beginPath();
            ctx.arc(proj.x, proj.y, proj.size, 0, Math.PI * 2);
            ctx.fill();
        }

        function drawPlacementIndicator() {
            ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.fillRect(0, PLACEMENT_Y_LIMIT, ARENA_WIDTH, ARENA_HEIGHT - PLACEMENT_Y_LIMIT);
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 5]);
            ctx.strokeRect(0, PLACEMENT_Y_LIMIT, ARENA_WIDTH, ARENA_HEIGHT - PLACEMENT_Y_LIMIT);
            ctx.setLineDash([]);
        }

        // --- EVENT HANDLERS ---
        function handleCardClick(e) {
            if (gameState !== 'playing') return;
            const button = e.currentTarget;
            const cardName = button.dataset.card;
            const card = CARD_DEFS[cardName];
            if (playerElixir < card.elixir) return;
            selectedCard = selectedCard === cardName ? null : cardName;
            updateCardUI();
        }

        function handleCanvasClick(e) {
            if (gameState !== 'playing' || !selectedCard) return;
            const rect = canvas.getBoundingClientRect();
            const x = (e.clientX - rect.left) * (ARENA_WIDTH / rect.width);
            const y = (e.clientY - rect.top) * (ARENA_HEIGHT / rect.height);
            if (y < PLACEMENT_Y_LIMIT) return;
            const card = CARD_DEFS[selectedCard];
            if (playerElixir >= card.elixir) {
                playerElixir -= card.elixir;
                spawnUnit(selectedCard, 'player', x, y);
                selectedCard = null;
                updateCardUI();
                updateElixirUI();
            }
        }

        function handleTouchStart(e) {
            e.preventDefault();
            if (gameState !== 'playing' || !selectedCard) return;
            const touch = e.touches[0];
            const rect = canvas.getBoundingClientRect();
            const x = (touch.clientX - rect.left) * (ARENA_WIDTH / rect.width);
            const y = (touch.clientY - rect.top) * (ARENA_HEIGHT / rect.height);
            if (y < PLACEMENT_Y_LIMIT) return;
            const card = CARD_DEFS[selectedCard];
            if (playerElixir >= card.elixir) {
                playerElixir -= card.elixir;
                spawnUnit(selectedCard, 'player', x, y);
                selectedCard = null;
                updateCardUI();
                updateElixirUI();
            }
        }

        // --- SPAWNING ---
        function spawnUnit(cardName, owner, x, y) {
            const card = CARD_DEFS[cardName];
            
            if (card.isBuilding) {
                const building = {
                    ...card,
                    id: Math.random(),
                    owner: owner,
                    x: x,
                    y: y,
                    hp: card.hp,
                    maxHp: card.hp,
                    lastAttackTime: 0,
                    target: null,
                    lifetime: card.lifetime,
                };
                buildings.push(building);
                return;
            }
            
            const unit = {
                ...card,
                id: Math.random(),
                owner: owner,
                x: x,
                y: y,
                hp: card.hp,
                maxHp: card.hp,
                lastAttackTime: 0,
                target: null,
                isMoving: false,
                lane: x < ARENA_WIDTH / 2 ? 'left' : 'right',
                animationTimer: Math.random() * Math.PI * 2,
            };
            units.push(unit);
        }

        function spawnProjectile(source, target) {
            const proj = {
                owner: source.owner,
                x: source.x,
                y: source.y,
                damage: source.damage,
                target: target,
                speed: 12,
                size: 6
            };
            projectiles.push(proj);
        }

        // --- UI RENDERING ---
        function renderCardHTML(cardName, showCost = true) {
            const card = CARD_DEFS[cardName];
            if (!card) return '';
            
            return `
                <button class="card" data-card="${cardName}">
                    ${showCost ? `<span class="elixir-cost">${card.elixir}</span>` : ''}
                    <span class="card-icon">${card.icon}</span>
                    <span class="card-name">${cardName.toUpperCase()}</span>
                </button>
            `;
        }

        function renderAuthScreen() {
            gameContainer.innerHTML = `
                <div class="flex items-center justify-center w-full h-full bg-gradient-to-br from-purple-600 via-pink-500 to-red-500">
                    <div class="auth-container">
                        <h1 class="text-4xl font-black text-center mb-2" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); -webkit-background-clip: text; -webkit-text-fill-color: transparent;">Clash-ish Royale</h1>
                        <p class="text-center text-gray-600 mb-4 text-sm">A strategic battle game</p>
                        
                        <div id="storage-status" class="text-xs text-center mb-4 px-3 py-2 rounded-lg bg-green-50 text-green-700">
                            <span id="storage-indicator">‚úì Data saves to your browser</span>
                        </div>
                        
                        <div id="auth-message"></div>
                        
                        <div id="login-form">
                            <input type="text" id="login-username" class="auth-input" placeholder="Username" autocomplete="username">
                            <input type="password" id="login-password" class="auth-input" placeholder="Password" autocomplete="current-password">
                            <button class="auth-button" onclick="handleLogin()">Login</button>
                            <button class="auth-button secondary" onclick="showRegister()">Create Account</button>
                        </div>
                        
                        <div id="register-form" style="display: none;">
                            <input type="text" id="register-username" class="auth-input" placeholder="Username (min 3 chars)" autocomplete="username">
                            <input type="password" id="register-password" class="auth-input" placeholder="Password (min 4 chars)" autocomplete="new-password">
                            <input type="password" id="register-confirm" class="auth-input" placeholder="Confirm Password" autocomplete="new-password">
                            <button class="auth-button" onclick="handleRegister()">Register</button>
                            <button class="auth-button secondary" onclick="showLogin()">Back to Login</button>
                        </div>
                        
                        <div class="text-xs text-center text-gray-500 mt-4">
                            <button onclick="showDebugInfo()" class="underline">Debug Info</button>
                        </div>
                    </div>
                </div>
            `;
        }

        function showDebugInfo() {
            const users = loadUsers();
            const userList = Object.keys(users);
            alert(`Debug Info:\n\nRegistered users: ${userList.length}\nUsernames: ${userList.join(', ') || 'None'}\n\nLocalStorage available: ${typeof(Storage) !== "undefined" ? 'Yes' : 'No'}\n\nCurrent user: ${currentUser || 'None'}`);
        }

        function renderMainMenu() {
            gameContainer.innerHTML = `
                <div class="menu-screen">
                    <div class="menu-content">
                        <h1 class="text-5xl font-black text-white mb-2 drop-shadow-lg text-center">Clash-ish Royale</h1>
                        <div class="text-sm text-gray-300 mb-4 text-center">Welcome, <span class="font-bold text-yellow-300">${currentUser}</span>!</div>
                        <div class="text-3xl font-bold text-yellow-300 mb-8 drop-shadow-md text-center">
                            üèÜ ${trophies}
                        </div>
                        <button class="game-button w-full max-w-xs" onclick="changeScreen('arena')">FIGHT!</button>
                        <button class="game-button w-full max-w-xs bg-gradient-to-r from-indigo-500 to-purple-600" onclick="changeScreen('deck')">Deck Customizer</button>
                        <button class="game-button w-full max-w-xs bg-gradient-to-r from-teal-500 to-cyan-600" onclick="changeScreen('shop')">Shop</button>
                        <button class="game-button w-full max-w-xs bg-gradient-to-r from-gray-600 to-gray-700" onclick="logoutUser()">Logout</button>
                    </div>
                </div>
            `;
        }

        function renderShop() {
            const cardsToBuy = SHOP_CARDS.filter(name => !ownedCards.includes(name));
            gameContainer.innerHTML = `
                <div class="menu-screen">
                    <div class="menu-content">
                        <h1 class="text-4xl font-black text-white mb-4">Shop</h1>
                        <div class="text-xl font-bold text-yellow-300 mb-6">üèÜ ${trophies} Trophies</div>
                        <div class="card-grid">
                            ${cardsToBuy.map(name => `
                                <div class="shop-card-item">
                                    ${renderCardHTML(name, true)}
                                    <button class="mt-3 text-sm bg-gradient-to-r from-pink-500 to-rose-600 text-white px-4 py-2 rounded-lg font-bold" onclick="buyCard('${name}')">Get Free</button>
                                </div>
                            `).join('')}
                            ${cardsToBuy.length === 0 ? '<p class="text-gray-300 col-span-full text-center">You own all cards!</p>' : ''}
                        </div>
                        <button class="game-button mt-6" onclick="changeScreen('main')">Back</button>
                    </div>
                </div>
            `;
        }

        function buyCard(cardName) {
            if (!ownedCards.includes(cardName)) {
                ownedCards.push(cardName);
                saveUserData();
                renderShop();
            }
        }

        function renderDeckCustomizer() {
            let availableCards = ownedCards.filter(name => !currentDeck.includes(name));
            gameContainer.innerHTML = `
                <div class="menu-screen">
                    <div class="menu-content">
                        <h1 class="text-4xl font-black text-white mb-4">Deck Builder</h1>
                        <p class="text-gray-200 mb-6 text-center px-4">Tap cards to swap them in or out</p>
                        <div class="w-full bg-black bg-opacity-40 rounded-2xl p-4 mb-6">
                            <h2 class="text-xl font-bold text-white mb-3 text-center">Your Deck (4 Cards)</h2>
                            <div class="flex justify-center gap-2 flex-wrap">
                                ${currentDeck.map(name => `
                                    <button class="card" data-card="${name}" onclick="removeFromDeck('${name}')">
                                        <span class="elixir-cost">${CARD_DEFS[name].elixir}</span>
                                        <span class="card-icon">${CARD_DEFS[name].icon}</span>
                                        <span class="card-name">${name.toUpperCase()}</span>
                                    </button>
                                `).join('')}
                                ${currentDeck.length < 4 ? '<div class="w-20 h-28 border-2 border-dashed border-white rounded-lg flex items-center justify-center text-white text-xs">Empty</div>'.repeat(4 - currentDeck.length) : ''}
                            </div>
                        </div>
                        <div class="w-full bg-black bg-opacity-40 rounded-2xl p-4">
                            <h2 class="text-xl font-bold text-white mb-3 text-center">Collection (${ownedCards.length})</h2>
                            <div class="flex flex-wrap justify-center gap-2">
                                ${availableCards.map(name => `
                                    <button class="card ${currentDeck.length >= 4 ? 'disabled' : ''}" data-card="${name}" onclick="addToDeck('${name}')">
                                        <span class="elixir-cost">${CARD_DEFS[name].elixir}</span>
                                        <span class="card-icon">${CARD_DEFS[name].icon}</span>
                                        <span class="card-name">${name.toUpperCase()}</span>
                                    </button>
                                `).join('')}
                                ${availableCards.length === 0 ? '<p class="text-gray-300 text-center w-full">All cards in deck!</p>' : ''}
                            </div>
                        </div>
                        <button class="game-button mt-6" onclick="changeScreen('main')">Back</button>
                    </div>
                </div>
            `;
        }

        function removeFromDeck(cardName) {
            const index = currentDeck.indexOf(cardName);
            if (index > -1) {
                currentDeck.splice(index, 1);
                saveUserData();
                renderDeckCustomizer();
            }
        }

        function addToDeck(cardName) {
            if (currentDeck.length < 4 && !currentDeck.includes(cardName)) {
                currentDeck.push(cardName);
                saveUserData();
                renderDeckCustomizer();
            }
        }

        function renderArena() {
            gameContainer.innerHTML = `
                <canvas id="game-canvas"></canvas>
                <div id="game-over-screen">
                    <h2 id="game-over-text">You Win!</h2>
                    <button class="game-button" onclick="initArena()">Play Again</button>
                    <button class="game-button" style="background: linear-gradient(90deg, #616161, #757575);" onclick="changeScreen('main')">Main Menu</button>
                </div>
                <div id="ui-bar">
                    <div id="elixir-container">
                        <div id="elixir-bar"></div>
                        <span id="elixir-count">5</span>
                    </div>
                    <div id="card-hand">
                        ${currentDeck.map(name => renderCardHTML(name, true)).join('')}
                    </div>
                </div>
            `;
            initArena();
        }

        function showMessage(message, isError = false) {
            const messageDiv = document.getElementById('auth-message');
            if (messageDiv) {
                messageDiv.innerHTML = `<div class="${isError ? 'error-message' : 'success-message'}">${message}</div>`;
                setTimeout(() => {
                    messageDiv.innerHTML = '';
                }, 3000);
            }
        }

        function showLogin() {
            document.getElementById('login-form').style.display = 'block';
            document.getElementById('register-form').style.display = 'none';
            document.getElementById('auth-message').innerHTML = '';
        }

        function showRegister() {
            document.getElementById('login-form').style.display = 'none';
            document.getElementById('register-form').style.display = 'block';
            document.getElementById('auth-message').innerHTML = '';
        }

        function handleLogin() {
            const username = document.getElementById('login-username').value.trim();
            const password = document.getElementById('login-password').value;
            
            const result = loginUser(username, password);
            
            if (result.success) {
                showMessage(result.message, false);
                setTimeout(() => {
                    changeScreen('main');
                }, 500);
            } else {
                showMessage(result.message, true);
            }
        }

        function handleRegister() {
            const username = document.getElementById('register-username').value.trim();
            const password = document.getElementById('register-password').value;
            const confirm = document.getElementById('register-confirm').value;
            
            if (password !== confirm) {
                showMessage('Passwords do not match', true);
                return;
            }
            
            const result = registerUser(username, password);
            
            if (result.success) {
                showMessage(result.message, false);
                setTimeout(() => {
                    showLogin();
                }, 1500);
            } else {
                showMessage(result.message, true);
            }
        }

        function changeScreen(screenName) {
            currentScreen = screenName;
            renderApp();
        }

        function renderLoading() {
            gameContainer.innerHTML = `
                <div class="menu-screen">
                    <div class="flex flex-col items-center justify-center h-full">
                        <svg class="animate-spin h-16 w-16 text-white mb-4" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                            <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                            <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                        </svg>
                        <p class="text-white text-xl">Loading...</p>
                    </div>
                </div>
            `;
        }

        function renderApp() {
            switch(currentScreen) {
                case 'auth':
                    renderAuthScreen();
                    break;
                case 'main':
                    renderMainMenu();
                    break;
                case 'shop':
                    renderShop();
                    break;
                case 'deck':
                    renderDeckCustomizer();
                    break;
                case 'arena':
                    renderArena();
                    break;
                default:
                    renderAuthScreen();
            }
        }

        // Make functions globally available
        window.changeScreen = changeScreen;
        window.buyCard = buyCard;
        window.addToDeck = addToDeck;
        window.removeFromDeck = removeFromDeck;
        window.initArena = initArena;
        window.handleLogin = handleLogin;
        window.handleRegister = handleRegister;
        window.showLogin = showLogin;
        window.showRegister = showRegister;
        window.logoutUser = logoutUser;
        window.showDebugInfo = showDebugInfo;

        // Start the app
        function startApp() {
            renderLoading();
            setTimeout(() => {
                currentScreen = 'auth';
                renderApp();
            }, 500);
        }
        
        startApp();
    </script>
</body>
</html>